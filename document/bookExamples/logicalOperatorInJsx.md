## 로직 연산자
- 삼항 연산자가 조건문의 참 거짓에 따라 서로 다른 결과 값을 반환하는 것과 달리, AND 논리 연산자는 참일 경우에만 값을 반환하는 로직을 가지고 있다.

### 불리언
- 불리언 타입이란? 불리언 타입이란 `true`, `false`의 두 가지 값을 가진다. 조건문은 불리언 타입을 반환하며 참이면 `true` 거짓이면 `false`를 실행한다.
- 불리언 타입은 조건문에서 참, 거짓을 판별하는데 쓰인다. 삼항 연산자의 문법 `조건문 ? 참일_때_반환할_값 : 거짓일_때_반환할_값`에서의 조건문, 또는 if문에서의 `if(조건문) {}`에서 조건문으로 사용된다.

### 자동 형변환
- 자바스크립트에서 조건문은 불리언 타입의 값을 받지만 조건문 안의 자바스크립트 코드가 `true`, `false`를 반환하지 않는 경우도 있는데, 자바스크립트는 형변환 언어이다. 예를 들어 수의 경우에는 `0`은 `false`, `0`이 아닌 수는 `true`로 형변환이 되며, 문자열의 경우에는 빈 문자열 `''`은 `false`, 비지 않은 문자열은 `true`로 형변환이 된다.

### 명제
- A : 1 + 1 은 2이다.
- B : 8 / 2 는 4이다.
- C : 3 * 3 은 8이다.
- 위의 A, B, C 문장은 참 거짓을 판별할 수 있는 문장이다. 참 거짓을 판단할 수 있는 문장을 '명제'라고 부른다.
- A 이고 B 이면 이 문장은 참일까? A 문장도 참이고 B 문장도 참이기 때문에 A and B 문장도 참이된다.
- A 이고 C 이면 이 문장은 참일까? A 문장이 참인 것에 반해 C 문장은 참이 아니기 때문에 A and C 문장은 거짓이 된다.
- A 또는 B 이면 이 문장은 참일까? A 문장도 참이고 B 문장도 참이기 때문에 A and B 문장도 참이된다.
- A 또는 C 이면 이 문장은 참일까? A 문장은 참이지만 C 문장은 참이아니다. 하지만 '또는'으로 연결되어 있기 때문에 두 문장 중 하나가 참이면 참이된다. 따라서 A or C는 참이 된다.
- 위의 A, B, C와 같이 참 거짓을 명확하게 구분할 수 있는 하나의 진술이라는 것이란 것을 '단일 명제'라고 부른다.
- 명제는 '또는' 이나 '이고'를 붙여서 연결할 수 있으며, 이렇게 연결된 문장 또한 참, 거짓을 구분할 수 있기 때문에 명제에 해당하고 '합성 명제'라고 부른다.
- 프로그래밍 언어에서도 참, 거짓을 판별할 수 있는 코드가 있다. `1 + 1 === 2`, `8 / 2 === 4`, `3 * 3 === 8` 모두 `true` 또는 `false`를 반환하기 때문에 명제에 해당한다.
- 명제는 참, 거짓을 판단할 수 있기 때문에 프로그래밍 언어에서는 보통 '조건문'이라고 불린다.

### 논리 연산자
- 명제와 명제를 잇는 '또는(or)'과 '이고(and)'에 해당하는 문법을 자바스크립트에서는 `&&` `||`으로 표현한다. 이를 통해서 합성 명제를 만들 수 있다.

### 명제를 자바스크립트로 만들어 보기
```js
(() => {
	const A = 1 + 1 === 2;
	const B = 2 + 2 === 4;
	const C = 3 * 3 === 8;
	console.log(A);
	console.log(B);
	console.log(C);
})();
```

#### 합성 명제 만들기
```js
(() => {
	const A = 1 + 1 === 2;
	const B = 2 + 2 === 4;
	const C = 3 * 3 === 8;
	const AandB = A && B;
	const AandC = B && C;
	const AorB = A || B;
	const AorC = A || C;
	console.log(AandB);
	console.log(AandC);
	console.log(AorB);
	console.log(AorC);
})();
```

### 자바스크립트의 명제
- 프로그래밍 언어에서 명제라는 것은 하나의 식이 불리언 타입의 값인 true　또는 false를 반환하면 된다.
- 자바스크립트와 같은 자동 형변환이 되는 언어의 경우에는 모든 값이 불리언 값으로 형변환이 될 수 있으므로 값을 반환하는 모든 것이 명제가 될 수 있다.
- 자바스크립트의 모든 값이 불리언 타입으로 형변환이 된다는 것은, 참/거짓이 나뉘는 것이기 때문에 논리학에서 볼 때는 명제라고 할 수 없지만, 프로그래밍 언어에서는 명제로 다룰 수 있는 것이다.

### AND 연산자
- AND로 연결된 함성 명제는 모두 참이어야 전제 진술이 참이 되며, 하나라도 거짓이면 전체 진술이 거짓이 되기 때문에, 프로그래밍 언어에서는 거짓을 만났을 때 합성 명제의 나머지 부분을 실행하지 않고 거짓을 반환한다.
```js
(() => {
	const A = () => {
		console.log('run A');
		return 1 + 1 === 2;
	};
	const B = () => {
		console.log('run B');
		return 2 + 2 === 4;
	}
	const C = () => {
		console.log('run C');
		return 3 * 3 === 8;
	}

	console.log(A() && C() && B());
})();
```
- 명제는 위와 같이 함수로 만들 수도 있다. 함수로 만든 이유는 각각의 명제가 실행이 되는지 확인하기 위해서이다.
- 위의 코드는 `run A` `run C` `false` `undefined`의 값을 출력한다. `A()` 함수가 실행 되어서 `run A`가 찍히고, `C()` 함수가 실행 되어서 `'run C'`가 찍히고, `A() && C() && B()`가 실행되면서 `false`가 찍히고 전체를 감싸고 있는 즉시 실행함수가 `return`이 없으므로 `undefined`를 반환한다.
- 그런데 `A() && C() && B()`가 실행이 될 때 `'run B'`가 찍히지 않았다. 그 이유는 `A() && C()`까지만 실행이 되고 ` && B()`가 실행되지 않았기 때문이다. 자바스크립트에서 AND 연산은 거짓을 만나면 뒤에 합성 명제가 남아 있더라도 어차피 명제가 거짓이 되기 때문에 연산의 효율성을 위해서 거짓이 된 부분에서 실행이 끝난다.

### OR 연산자
- OR로 연결된 합성 명제는 하나라도 참이면 전체 진술이 참이되며, 전체 진술을 이루는 모든 명제가 거짓이면 거짓이 반환되기 때문에 참을 만나면 합성 명제의 나머지 부분을 실행하지 않고 참을 반환한다.
```js
(() => {
	const A = () => {
		console.log('run A');
		return 1 + 1 === 2;
	};
	const B = () => {
		console.log('run B');
		return 2 + 2 === 4;
	}
	const C = () => {
		console.log('run C');
		return 3 * 3 === 8;
	}

	console.log(C() || B() || A());
})();
```
- 위 명제를 만나면 `run C` `run B` `false` `undefined`가 출력이 된다. `C()`가 실행이 되어서 `'run C'`가 실행이 되고, `B()`가 실행이 되어서 `'run B'`가 실행이 되고, `C() && B() && A()`가 실행이 되면서 `false`가 찍히고 전체를 감싸고 있는 즉시 실행함수가 `return`이 없으므로 `undefined`를 반환한다.
- 그런데 `C() && B() && A()`가 실행이 될 때 `'run A'`가 찍히지 않았다. 그 이유는 `C() || B()`까지만 실행이 되고, `|| A()`가 실행이 되지 않았기 때문이다. OR 연산의 경우 각각의 단일 명제가 모두 거짓이 될 때 전체 명제가 거짓이 되므로 `C()`는 거짓이기 때문에 문제가 없지만 `B()`가 참이 되면서 남은 명제를 확인해도 전체 명제는 어차피 참이 되기 때문에 연산의 효율성을 위해서 참이 된 부분에서 실행이 끝난다.

### 자바스크립트 합성 명제의 특징
- 자바스크립트의 모든 값은 불리언 타입의 값으로 형변환이 된다. 수의 경우 0일 때는 `false`가 되고, 0이 아닐 때는 `true`가 된다. 문자열이 경우 `''` 빈 문자열인 경우에는 `false`가 되고, 빈 문자열이 아닐 때는 `true`가 된다.
- 논리학에서 합성 명제는 전체 문장의 참과 거짓만을 반환하는 것에 반해, 자바스크립트는 합성 명제를 판단하다가 실행이 끝난 부분의 값을 반환한다.
```js
console.log(1 && '이 부분은 반환되지 않는다' && '여기서 실행이 멈춘다.');
```
- `1`은 `true`로 형변환이 된다. AND 연산자로 연결되었기 때문에 전체 합성 명제의 참 거짓을 판단하기 위해서는 `false`에 해당하는 값이 나올 때까지 남은 함성 명제를 확인한다. `'이 부분은 반환되지 않는다'`도 `true`로 형변환이 된다. 따라서 다음 명제도 확인한다. `'여기서 실행이 멈춘다.'`도 `true`로 형변환이 된다. 전체 합성 명제를 확인을 하더라도 false가 나오지 않았으므로 `true`로 평가된다. 그런데 위 합성 명제는 논리학적인 관점에서 참인 문장으로 `true`를 반환해야 하지만 자바스크립트의 경우 `true`를 반환하지 않고 합성 명제가 실행이 된 부분의 값을 반환한다. 따라서 `true`를 반환하지 않고 `'여기서 실행이 멈춘다.'`라는 값을 반환한다. 그리고 이 값을 반환해도 `true`로 형변환이 되기 때문에 형변환된 관점에서 보면 참을 반환하는 것이긴 하다.
```js
console.log(1 && '이 부분은 반환되지 않는다' && 0 && '이 부분은 실행되지 않는다.');
```
- 위의 조건문이 반환하는 값은 무엇일까? AND 연산으로 이뤄진 전체 합성 명제가 참인지 확인하기 위해서는 하나라도 거짓이 나오면 안 되기 때문에 거짓이 나오는 명제가 있는지 확인한다. 따라서 참인 명제가 나오고 남은 명제가 있다면 뒤의 명제도 확인을 하며, 거짓인 명제가 나오면 전체 문장이 어차피 거짓이기 때문에 거짓을 반환하고 남은 명제를 확인하지 않고 실행을 끝낸다.
- `1`은 `true`에 해당하고 전체 문장의 참 거짓을 확인하기 위해서는 남은 명제를 확인해야 한다. AND 연산자로 연결되었으므로 다음 명제를 확인한다. `'이 부분은 반환되지 않는다'`는 `true`에 해당하고 전체 문장의 참 거짓을 확인하기 위해서는 남은 명제를 확인해야 한다. `0`은 `false`에 해당하고 이 부분으로 인해 전체 합성 명제는 `false`로 평가된다. 조건식의 전체 결과가 나왔으므로 나머지 부분을 더 이상 실행하지 않는다. 하지만 자바스크립트 이므로 `false`를 반환하지 않고 마지막으로 실행된 값을 반환하므로 console.log로 찍히는 값은 `0`이다.
