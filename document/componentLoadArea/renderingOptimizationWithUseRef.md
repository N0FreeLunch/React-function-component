## 현재 코드의 문제점
- input 태그의 입력 정보를 `useState`로 저장하기 때문에 input 태그에 값을 입력할 때마다 컴포넌트 함수가 다시 실행되어 컴퓨팅 리소스의 낭비가 일어난다.
- `useRef`라는 기술을 사용하여 유저가 input 태그에 값을 입력하여도 컴포넌트 함수가 다시 실행되지 않게 코드를 작성할 수 있다.

## 리액트의 특징
- 리액트에서 어떤 값을 저장하기 위해서는 상태 변경 함수에 변경되는 값을 전달해야 한다. 상태 변경 함수가 실행이 되면 리액트는 컴포넌트 함수를 다시 실행하여 컴포넌트 함수 내부에서 선언되는 상태 변수의 값을 앞서 상태 변경 함수에 전달했던 값으로 세팅을 한다.
- 리액트에서 화면에 출력되는 값을 변경하기 위해서는 상태 변경 함수를 실행해야 한다. 상태 변경 함수가 실행되면 컴포넌트 함수가 실행되고 컴포넌트 함수가 반환하는 JSX와 이전에 렌더링된 JSX와 비교하여 변경점이 있다면 변경된 부분의 JSX 태그를 화면에 다시 랜더링 하는 방식이다. 만약 태그의 속성만 변경되었다면 리액트는 태그를 대체하지 않고 랜더링 되는 태그의 속성만 변경하도록 한다.

## 왜 useRef가 만들어졌는가?

### 컴포넌트 함수를 실행하지 않는 저장 방식의 필요성
- 리액트에서 컴포넌트 함수 외부에 var 또는 let을 사용해서 변수를 만들면 컴포넌트 함수를 다시 실행하지 않고서도 변수에 값을 저장할 수 있고, 컴포넌트 함수를 다시 실행하더라도 변수에 값이 사라지지 않는다. 하지만 이는 동일한 컴포넌트 함수를 여러번 재사용하는 경우 변수의 공유가 일어나기 때문에 안티 패턴이 되어 사용하지 않는다고 하였다.
- 리액트에서 상태를 통해서 값을 저장하기 위해서는 컴포넌트 상태 변경 함수를 통해 상태 변경을 시도하고, 상태 변경에 따라서 컴포넌트 함수가 다시 실행되면서 함수 내부의 상태 변수의 값이 할당될 때, 컴포넌트 함수가 실행되기 전 상태에서 지정된 변경 값을 상태 변수의 초기 값으로 할당하는 방식으로 이뤄진다. 하지만 이 방식이 컴퓨팅 리소스를 소모하기 때문에 컴포넌트 함수 외부의 var, let과 비슷한 방식으로 컴포넌트 함수를 재시작 하지는 않지만 안티패턴이 아닌 방식의 값 저장 방식을 만들 필요성이 있다.
- **1. "변수에 값을 저장할 때 컴포넌트 함수를 실행하지 않으면서"**, **2. "컴포넌트 함수가 다시 실행될 때는 저장한 변수 값을 컴포넌트 함수에서 초기값으로 갖는"** 저장 방식을 만들면 컴포넌트 함수 외부에 변수를 두지 않고도 변경되는 값을 저장할 수 있다.

### 일반적인 태그와 달리 input 태그의 특이점
- 일반적인 태그와 달리 input 태그의 특이한 점은 브라우저에서 제공하는 기능이란 것이다. input 태그에 입력하는 값은 유저가 HTML의 태그로 만들지 않아도 화면에 입력한 값이 표시된다. 일반적인 태그는 화면에 나타나는 모습을 바꾸기 위해 태그 자체를 변경시켜야 하지만, input 태그와 같은 유저의 입력을 받는 태그는 유저의 입력을 받을 때 태그 자체를 변경시키지 않아도 된다.

### 상태 변경을 사용하지 않아도 컴포넌트 함수의 실행에 따른 값 유지의 필요성
- 리액트의 상태 변경에 따른 컴포넌트 함수의 재실행은 일반적인 태그의 변경을 화면에 표시할 때 쓰는 방식이지만, input 태그와 같이 태그의 직접적인 변경이 없을 경우, 유저 입력 값을 저장하기 위한 용도로 컴포넌트 함수를 재실행한다는 것은 컴퓨팅 리소스 낭비이다.
- input 태그의 유저의 입력값을 화면에 표시하는 기능은 태그를 화면에 다시 그릴 필요 없이, 브라우저가 제공하는 기능이기 때문에 리액트가 태그를 화면에 다시 그릴 필요가 없다. 유저의 입력 값을 자바스크립트 코드로 가져오려면 유저의 입력이 있을 때 마다 함수를 실행하는 이벤트를 이용해서 유저의 입력 값을 자바스크립트 코드로 가져와야 한다.
- input 태그에 입력한 값을 저장할 때는 컴포넌트가 다시 실행되어도 저장된 값이 유지될 수 있도록 저장을 해야한다. 하지만 리액트에서 컴포넌트 함수가 다시 실행 되어도 저장한 값을 보존하려면 상태 변경 함수를 이용한 저장방식을 써야 한다.
- 하지만 상태 변경 함수를 이용하면 컴포넌트 함수가 다시 실행되어 버리기 때문에 컴퓨팅 리소스 낭비에 대한 대책이 될 수 없다. 1. **저장할 때 직접적으로 컴포넌트 함수를 다시 실행하지 않으면서**도 2. **컴포넌트 함수가 다시 실행이 되어도 저장한 값을 보존**할 수 있는 기능이 필요하다.