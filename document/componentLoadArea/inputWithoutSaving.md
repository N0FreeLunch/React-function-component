## useRef로 태그 다루기

### 문서 객체 모델
- 브라우저에 로드된 HTML의 태그를 자바스크립트는 객체로 다룰 수 있다. 일반적으로 `document.querySelector('선택할 태그의 CSS 셀렉터')` 또는 `document.getElementByID('선택할 태그의 아이디')` 또는 `document.getElementsByClassName('선택할 태그의 클래스 속성 이름')` 등의 브라우저에서 제공하는 문서 객체 모델(HTML 문서의 태그들을 자바스크립트의 객체로 불러서 컨트롤 한다는 의미)를 통해서 태그를 자바스크립트로 다룰 수 있는 기능을 제공한다.
- 브라우저에 로드된 태그는 자바스크립트의 문서 객체 모델을 통해서 객체로 반환되는데 Node라는 타입의 객체가 된다. 선택된 태그는 Node라는 객체에 들어 있는 속성을 모두 사용할 수 있다. 태그를 자바스크립트로 컨트롤 할 수 있는 객체를 문서 객체라고 하자. 그러면 `문서_객체.parentNode`, `문서_객체.childNodes`, `문서_객체.firstChild`, `문서_객체.lastChild`등의 방식으로 Node 타입의 객체의 속성을 사용할 수 있다.
- 브라우저에 로드된 태그의 종류에 따라서 Node 타입의 객체의 속성만 사용할 수 있는 것이 아니라, Element 타입의 객체의 속성도 사용할 수 있다. `문서_객체.innerHTML`, `문서_객체.getAttribute()`, `문서_객체.querySelector()`, `문서_객체.className` 등의 방식으로 Element 타입 객체의 속성을 사용할 수 있다.
- Node 타입의 객체가 각 태그 간의 위치 관계를 파악할 수 있는 기능을 제공하는 것과 달리 Element 타입의 객체는 우리가 일반적으로 자바스크립트 태그의 어떤 속성 값을 가져오거나 속성과 속성에 값을 부여할 수 있는 기능을 제공한다.
- 더 자세한 내용은 MDN 문서의 내용을 참고하도록 하자. [Element 객체](https://developer.mozilla.org/ko/docs/Web/API/Element), [Node 객체](https://developer.mozilla.org/ko/docs/Web/API/Node)

### 리액트의 JSX로 태그를 변화시키지 않고 태그를 직접 변경하면 발생하는 일
- 문서 객체 모델은 브라우저에 로드된 태그를 자바스크립트에서 컨트롤 하기 위해서 사용하는 브라우저에서 제공하는 기능이다.
- 리액트는 상태변경을 통해서 컴포넌트 함수를 다시 실행하고, 컴포넌트 함수가 다시 실행되면서 JSX 태그를 변화시키고, 변화된 JSX 태그가 이전에 랜더링된 태그 구조와 비교했을 때 변경 사항이 있으면 해당 부분의 태그 또는 태그의 속성을 교체하는 방식으로 동작한다.
- 리액트에서 태그를 변경하는 방식은 기본적으로 상태 변경을 기준으로 이뤄지며, 문서 객체 모델을 직접 사용하여 태그의 값을 변경하는 방식을 사용하지 않는다.
- 리액트는 이전에 저장해 둔 랜더링된 태그 구조와 컴포넌트 함수의 재실행으로 인해 랜더링 될 태그 구조의 차이를 비교하여 변경 사항이 있으면 변경하게 된다. 하지만, 리액트의 컴포넌트 함수에 의해 랜더링 되는 값에 의한 변경이 아니라 다른 요인에 의해 태그의 값을 변경하는 경우에는 이전 랜더링 때의 태그 구조와 다음 랜더링 할 태그 구조를 비교하므로 외부 요인에 의해 변경된 태그는 이전 랜더링 된 태그의 구조에 속하지 않으므로  비교에서 누락된다.
- 예를 들어 어떤 리액트의 상태 변화에 따라서 변화 값을 표시하는 태그가 있다고 하자. 이 태그를 브라우저의 콘솔 창 옆의 Element 매뉴에서 태그를 선택해서 키보드의 delete 키 등을 사용하여 삭제 했다고 해 보자. 그러면 리액트의 상태 변화가 일어나고 태그에 표시될 값을 변경해야 하는데 태그가 사라졌으므로 존재하지 않는 태그에 값을 변경하도록 명령을 내리게 된다. 랜더링 전후의 태그 구조에서 태그를 만드는 것이 아니라 태그의 값만 변경하는 것이므로 리액트는 새로 태그를 생성하지 않고 태그에 값만 변경하라는 명령을 내리기 때문에 사라진 태그는 해당 태그 내부의 값이 리액트의 상태 변화에 의해 변경이 되어도 태그가 새로 생성되지 않고 삭제된 채 남아있게 된다.
```html
<h3 style="margin-left: 10px;">current component number : 5</h3>
```
- 위 태그를 삭제한 후, prev 버튼 또는 next 버튼을 눌러보자. 태그가 새로 생성되지 않는 것을 알 수 있다.
- 하지만, 태그를 삭제하지 말고 `current component number : 5`의 값만 바꾼 후에 prev 버튼이나 next 버튼을 눌러보자. 그러면 `current component number : 4`의 값으로 다시 원상태로 바뀔 것이다. 이것은 이전의 랜더링 된 `current component number : 5`의 값에서 다음으로 랜더링 되는 `current component number : 4`의 값으로 값이 변했기 때문에 리액트의 상태변화가 일어나면서 리액트는 이 태그 내부의 택스트 값을 바꾸기 때문이다. 그런데 수 부분만이 아닌 `current component number : 4` 택스트 전체가 바뀌었다. 이것은 리액트가 동일한 태그에는 속성 단위로 변경 사항을 인식하기 때문에 속성 전체를 바꾸는 것으로 보면 된다.

### AI 바둑 대리기사의 비유
- 알파고의 등장이후 이를 따라 만든 AI 바둑 프로그램으로 명성을 떨치는 '카타고'와 '절예'라는 프로그램이 있다.
- 이 두 프로그램 중에서 어느 프로그램이 기량이 더 높은지를 판단하기 위해서 컴퓨터 프로그램을 만들어서 바둑판의 화면에 서로 수를 두도록 만들었다고 하자.
- 이 바둑을 중계하기 위해 인간 대리기사 2명이 한 명은 카타공의 수를 다른 한 명은 절예의 수를 실제 바둑판에 번갈아가면서 두도록 한다.
- 경기가 시작이 되고 카타고와 절예가 수를 교환하는 가운데 대리 기사들이 AI를 따라 두는 바둑판에 돌을 떨어뜨려서 바둑판 일부의 돌을 흐뜨려 놓았다.
- 하지만 AI의 바둑돌 교환은 계속 되면서 바둑 돌을 바로 잡을 시간이 없던 대리 기사들은 AI가 두는 대로 바둑돌을 계속 둔다.
- AI는 실물 바둑판의 상황이 어떻든 AI 끼리 수를 교환하는 것에만 관여한다. 따라서 AI의 수 교환이 일어나는 프로그램의 영역에서는 외부의 영향으로 돌의 위치가 바뀌거나 하지 않으며 실물 바둑판의 상황에도 영향을 받지 않는다.
- 리액트도 이와 비슷하다. 리액트 내부의 상태관리를 통해서 태그를 랜더링 하는 것은 AI가 바둑을 서로 교환하는 것에 해당하고, 실제 화면에 표시되는 태그는 실물 바둑판에 해당한다. 실물 바둑판이 어떻게 되든 AI는 AI끼리 교환하는 바둑돌의 변화만 감지한다. 마찬가지로 리액트는 실제 브라우저에 랜더링 된 태그가 어떻게 되든 리액트 내부의 이전 랜더링된 태그 구조와 다음으로 랜더링할 태그 구조의 변화만을 감지한다.